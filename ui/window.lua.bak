if not ItemTrig then return end
if not ItemTrig.UI then
   ItemTrig.UI = {}
end

--[[--
   WINDOW
   
   To create a WWindow subclass:
   
      local MySubclass = setmetatable({}, {__index = ItemTrig.UI.WWindow})
      --
      -- And to override a method:
      --
      function MySubclass:install(control, options)
         local result = ItemTrig.UI.WWindow.install(self, control, options) -- call super
         setmetatable(result, self) -- needed for proper constructor behavior
         --
         -- ... additional functionality ...
         --
         return result
      end
--]]--

ItemTrig.UI.WWindow = {}
ItemTrig.UI.WWindow.__index = ItemTrig.UI.WWindow
function ItemTrig.UI.WWindow:install(control, options)
   assert(control ~= nil, "Cannot install WWindow functionality on a nil control.")
   if control.widgets and control.widgets.window then
      return control.widgets.window
   end
   if not options then
      options = {}
   end
   local result = {
      controls = {
         window    = control,
         blocker   = control:GetNamedChild("ModalUnderlay"), -- the control used to block mouse focus
         titleBar  = control:GetNamedChild("TitleBar"),
         titleText = nil
      },
      --
      prefs = {
         modalOnly = options.modalOnly or false, -- boolean OR the name of the only allowed opener
      },
      modalState = {
         child    = nil, -- WWindow: a modal that we've opened
         opener   = nil, -- WWindow: the window that has us open as a modal
         deferred = nil, -- Deferred to resolve when we're closed; allows opener to respond to our closing
      },
   }
   assert(result.controls.blocker ~= nil, "A WWindow control must have a child named \"$(parent)ModalUnderlay\".")
   if result.controls.titleBar then
      result.controls.titleText = result.controls.titleBar:GetNamedChild("Title")
   end
   setmetatable(result, self)
   do -- link the wrapper to the control via an expando property
      if not control.widgets then
         control.widgets = {}
      end
      control.widgets.window = result
   end
   return result
end
function ItemTrig.UI.WWindow:cast(control)
   assert(control ~= nil, "Cannot cast a nil control to WWindow.")
   if getmetatable(control) == self then
      --
      -- TODO: this will fail on subclasses
      --
      return control
   end
   if control.widgets then
      return control.widgets.window
   end
   return nil
end
function ItemTrig.UI.WWindow:_onBeforeShow()
   --
   -- Subclasses can override this. Returning false cancels the show operation.
   --
   return true
end
function ItemTrig.UI.WWindow:_onBeforeOpenBy(opener)
   --
   -- Subclasses can override this. Returning false cancels the open operation. 
   -- The argument is a WWindow instance.
   --
   return true
end
function ItemTrig.UI.WWindow:_onModalHidden()
   --
   -- Subclasses can override this, but should always call super.
   --
   self.modalState.child = nil
   self.controls.blocker:SetHidden(true)
end
function ItemTrig.UI.WWindow:getModalOpener()
   return self.modalState.opener
end
function ItemTrig.UI.WWindow:show()
   local c = self.controls.window
   if not c:IsHidden() then
      return
   end
   if self.prefs.modalOnly then
      return
   end
   if not self:_onBeforeShow() then
      return
   end
   SCENE_MANAGER:ShowTopLevel(self.controls.window)
   self.controls.window:BringWindowToTop()
end
function ItemTrig.UI.WWindow:showModal(modal)
   assert(modal ~= nil, "Cannot show a nil modal.")
   local child = ItemTrig.UI.WWindow:cast(modal)
   assert(child ~= nil, "The specified modal isn't a valid WWindow.")
   do
      local other = child:getModalOpener()
      assert(child:getModalOpener() ~= self,   "This window is already showing the specified modal. Did you accidentally call this function twice?")
      assert(child:getModalOpener() == nil,    "The specified modal is already being shown.")
      assert(child.modalState.deferred == nil, "The specified modal's state has been mismanaged. The modal cannot be shown.")
   end
   assert(self.modalState.child == nil, "This window is already showing a modal.")
   if type(self.prefs.modalOnly) == "string" then
      local name = child.controls.window:GetName()
      if name ~= self.prefs.modalOnly then
         return nil
      end
   end
   if not child:_onBeforeOpenBy(self)
      return nil
   end
   if not child:_onBeforeShow()
      return nil
   end
   self.controls.blocker:SetHidden(false)
   self.modalState.child = child
   local deferred = ItemTrig.Deferred:new()
   deferred:done(self._onModalHidden, self)
   child.modalState.opener   = self
   child.modalState.deferred = deferred
   SCENE_MANAGER:ShowTopLevel(child.controls.window)
   child.controls.window:BringWindowToTop()
   return deferred
end
function ItemTrig.UI.WWindow:getTitle()
   return self.controls.titleText:GetText()
end
function ItemTrig.UI.WWindow:setTitle(text)
   return self.controls.titleText:SetText(text)
end